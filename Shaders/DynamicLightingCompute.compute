// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

#include "UnityCG.cginc"
#include "DynamicLighting.cginc"

StructuredBuffer<float3> lightmap_world;

// fetches a shadow bit as the specified uv coordinates from the lightmap data.
float3 lightmap_pixel_world(uint2 uv)
{
    return lightmap_world[uv.y * lightmap_resolution + uv.x];
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 world = lightmap_pixel_world(id.xy);

    // iterate over every dynamic light in the scene:
    float3 light_final = float3(0, 0, 0);
    for (uint k = 0; k < dynamic_lights_count; k++)
    {
        // get the current light from memory.
        DynamicLight light = dynamic_lights[k];

        // calculate the distance between the light source and the fragment.
        float light_distance = distance(world, light.position);

        // we can use the distance and guaranteed maximum light radius to early out.
        // confirmed with NVIDIA Quadro K1000M doubling the framerate.
        if (light_distance > light.radius) continue;
        
        // if this renderer has a lightmap we use shadow bits otherwise it's a dynamic object.
        // if this light is realtime we will skip this step.
        float map = 1.0;
        if (lightmap_resolution > 0 && light_is_dynamic(light))
        {
            uint shadow_channel = light_get_shadow_channel(light);

            // fetch the shadow bit and if it's black we can skip the rest of the calculations.
            // confirmed with NVIDIA Quadro K1000M that this check is cheaper.
            map = lightmap_pixel(id.xy, shadow_channel);
            //if (map == 0.0) continue;

            // apply a simple 3x3 sampling with averaged results to the shadow bits.
            map = lightmap_sample3x3(id.xy, shadow_channel, map);
        }
        
        // calculate the direction between the light source and the fragment.
        float3 light_direction = normalize(light.position - world);
        
        // spot lights determine whether we are in the light cone or outside.
        if (light_is_spotlight(light))
        {
            // anything outside of the spot light can and must be skipped.
            float2 spotlight = light_calculate_spotlight(light, light_direction);
            if (spotlight.x <= light.outerCutoff)
                continue;
            map *= spotlight.y;
        }
        else if (light_is_discoball(light))
        {
            // anything outside of the spot lights can and must be skipped.
            float2 spotlight = light_calculate_discoball(light, light_direction);
            if (spotlight.x <= light.outerCutoff)
                continue;
            map *= spotlight.y;
        }
        else if (light_is_watershimmer(light))
        {
            map *= light_calculate_watershimmer(light, world);
        }

        // a simple dot product with the normal gives us diffusion.
        //float diffusion = max(dot(i.normal, light_direction), 0);

        // important attenuation that actually creates the point light with maximum radius.
        float attenuation = saturate(1.0 - light_distance * light_distance / (light.radius * light.radius)) * light.intensity;

        // add this light to the final color of the fragment.
        light_final += light.color * attenuation /* diffusion  */ * map;
    }

    Result[id.xy] = float4(light_final, 1.0);
}
